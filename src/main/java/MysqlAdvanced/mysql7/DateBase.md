索引底层原理

在了解完了索引的类型之后 我们接着来看看索引是如何实现的

既然我们要通过索引来快速查找内容 那么如何设计索引就是我们的重点内容 因为索引是存储在硬盘上的跟我们之前使用的HashMap之类的不同 它们都是在内存中的
但是硬盘的读取速度远小于内存的速度 每一次IO操作都会耗费大量的时间 我们也不可能把整个磁盘上的索引全部导入内存 因此我们需要考虑尽可能多的减少IO次数
索引的实现可以依靠两种数据结构 一种是我们在javaSE阶段已经学习过的Hash表 还有一种就是B-Tree

我们首先来看看哈希表 实际上就是计算机Hash值来快速定位:

    通过对Key进行散列值计算 我们可以直接得到对应数据的存放位置 它的查询效率能够达到O(1) 但是它也存在一定的缺陷:

        > Hash索引仅仅能满足"=" "in"查询条件 不能使用范围查询
        > Hash碰撞问题
        > 不能用部分索引键来搜索 因为组合索引在计算哈希值的时候是一起计算的

    那么 既然要解决这些问题 我们还有一种方案就是使用类似于二叉树那样的数据结构来存储索引 但是这样相比使用Hash索引 会牺牲一定的读取速度

    但是这里并没有使用二叉树 而是使用了BTree 它是专门为磁盘数据读取设计的一种度为n的查找树:

        > 树中每个结点最多含有m个孩子 (m >= 2)
        > 除根节点和叶子结点外 其它每个结点至少有[ceil(m / 2)]个孩子
        > 若根节点不是叶子结点 则至少有2个孩子
        > 所有叶子结点都出现在同一层
        > 每个非终端结点中包含有n个键值信息: (P1 K1 P2 K2 P3 ... Kn Pn+1) 其中:
            1. Ki(i=1...n)为键值 且键值按顺序升序排序K(i-1) < Ki
            2. Pi为指向子树根的结点 且指针P(i)指向的子树中所有结点的键值均小于Ki 但都大于K(i-1)
            3. 键值的个数n必须满足: [ceil(m / 2)-1] <= n <= m-1

    比如现在我们要对键值为10的记录进行查找 过程如下:

        1. 读取根节点数据(目前进行了一次IO操作)
        2. 根据根节点数据进行判断得到10 < 17 因为P1指向的子树中所有值都是小于17的 所以这时我们将P1指向的节点读取(目前进行了两次IO操作)
        3. 再次进行判断 得到8 < 10 < 12 因为P2指向的子树中所有的值都是小于12大于8的 所以这时读取P2指向的节点(目前进行了三次IO操作)
        4. 成功找到

    我们接着来看 虽然BTree能够很好地利用二叉树查找树的思想大幅度减少查找次数 但是它的查找效率还是很低 因此它的优化版本B+Tree诞生了 它拥有更稳定的查询效率和更低的IO读取次数:

    我们可以发现 它和BTree有一定的区别:

        > 有n课子树的结点中含有n个键值 BTree只有n-1个
        > 所有的键值信息只在叶子结点中包含 非叶子节点仅仅保存子节点的最小(或最大)值 和指向叶子节点的指针 这样相比BTree某每一个节点在硬盘中存放了更少的内容(没有键值信息了)
        > 所有叶子结点都有一个根据大小顺序指向下一个叶子节点的指针Q 本质上数据就是一个链表

    这样 读取IO的时间相比BTree就减少了很多 并且查询任何键值信息都需要完整地走到叶子节点 保证了查询的IO读取次数一致 因此MySQL默认选择B+Tree作为索引的存储数据结构

    InnoDB与MyISAM实现的不同之处:

        > 数据本身就是索引的一部分(所以这里建议主键使用自增)
        > 非主键索引的数据实际上存储的是对应记录的主键值(因此InnoDB必须有主键 若没有也会自动查找替代)